# digest

Анализирует исходные файлы пользователя и сохраняет их в локальную базу. Каждый
каталог и каждый файл после этого станет отдельной записью в базе.

Предполагаемая структура пользовательских каталогов:

```
origin
  ├─── ~users.json
  └─── <user uuid>
           └─── folder
                  ├─── sub_folder
                  │        ├─── img1.jpg
                  │        ├─── img2.jpg
                  │        ├─── img3.jpg
                  │        ├─── ~info.json
                  │        ├─── ~config.json
                  │        └─── ~local_config.json
                  └─── ~item.json      
```

Каталог `origin` выступает корнем и хранит персональные каталоги всех
пользователей. Имена этих каталогов соответствуют UUID пользователей.

Внутри каждого из таких каталогов может располагаться произвольный набор файлов
и каталогов. В качестве метаинформации выступают json файлы, описывающие как
именно записи должны обрабатываться. Имя файла должно начинаться с `~` и может
быть как произвольным, так и иметь специальное значение. В основном
зарезервированные имена относятся к создаваемым сущностям, использование для
них отдельного файла позволяет немного упростить структуру json файла и сделать
более явным представление о том, что где искать.

Собрав все файлы в каталоге, система понимает как обрабатывать пользовательские
данные. Не имеет особого значения где будет размещено такое описание. Все эти
параметры в итоге будут собраны в один документ перед началом обработки.

Особые имена файлов:

1. `~users.json` - перечень всех создаваемых пользователей.
1. `~item.json` - описание создаваемой записи (одно на каталог).
1. `~groups.json` - перечень всех создаваемых групп.
1. `~synonyms.json` - перечень всех создаваемых синонимов.
1. `~config.json` - настройка этой записи и всех наследников.
1. `~local_config.json` - настройка только в рамках этого каталога.
1. `~info.json` - собирательное имя, в котором может быть всё выше названное.

Файл с любым другим именем, но подпадающий под шаблон, будет рассматриваться
аналогично `~info.json`. Если по каким-то причинам хочется создать в одном
каталоге несколько записей, они могут быть описаны в `~info.json`. Разница в
синтаксисе здесь сделана для упрощения файла `~item.json` т.к. он будет один в
99% случаев.

## Основные идеи обработки

Каждый каталог и каждый файл станут записями. При этом система постарается
вытащить максимум информации из расположения файлов, например цепочка каталогов
может быть преобразована в цепочку тегов в соответствующей записи.

При этом получится дерево, по которому можно передавать параметры. Например,
если на верхнем уровне вы опишете теги, эти теги распространятся на все записи
в каталогах ниже. Важно понимать, что деревьев в итоговом варианте не будет,
родительские записи от дочерних отличаться будут только набором тегов.
Наследование параметров распространяется при анализе исходников и заполнении
базы, но во время работы приложения уже не используется.

### Users

Внутри **omoide** пользователи представлены крайне просто - у них только uuid и
псевдоним. Полноценные пользователи будут существовать в приложении, здесь же
это просто ключи для контроля доступа. Все пользовательские настройки, имя,
адрес и тому подобное должны храниться и обрабатываться в приложении.

Идентификаторы пользователя здесь и в приложении тоже разные, но для работы они
должны быть сопоставлены один к одному.

Пример файла `~users.json`:

```json
[
    {
        "uuid": "$=[user public]",
        "byname": "Public user"
    },
    {
        "uuid": "$=[user private]",
        "byname": "Private user"
    }
]
```

Параметр `byname` ни на что не влияет и используется администратором для
различения пользователей.

Про uuid можно прочитать в разделе [Кеширование uuid](#Кеширование-uuid).

### Items

Краеугольный камень всей системы. От того, насколько хорошо описаны записи,
зависит работа всей системы.

В общем случае один каталог это одна запись. Например, одна книга. Каждая из
страниц книги тоже станет записью, но их описание формируется в неявном виде.

Пример `~items.json` с полным синтаксисом для записи:

```json
{
    "meta": {
        "registered_on": "2021-08-14",
        "registered_by": "${user public}",
        "comment": "",
        "type": ""
    },
    "local": {
        "copyright": {
            "author": "John Smith",
            "author_url": "https://somsite.com/john-smith",
            "url": "https://somsite.com/images/some.jpg"
        },
        "media": {
            "width": 640,
            "height": 480
        }
    },
    "tags": [
        "browney"
    ],
    "hidden_tags": [
        "some tag"
    ],
    "users_can_see": [
        "${user user4}"
    ],
    "groups_can_see": [
        "${group public}"
    ],
    "manual": {
        "animal-1239134.jpg": {
            "tags": [
                "apple"
            ],
            "config": {
                "add_exif": false
            }
        },
        "animal-1239402.jpg": {
            "tags": [
                "peanut"
            ]
        }
    },
    "config": {},
    "local_config": {}
}
```

Доступные для изменения параметры:

| Поле                      | Значение                                        |
| --------------------------|-------------------------------------------------|
|      Автоматические       |                                                 |
| type                      | Тип записи: image, animated_image, video, etc.  |
| name                      | Берётся из имени каталога, для файлов пустое    |
| parent_uuid               | uuid родительской записи (если есть)            |
| size                      | Размер данных в байтах                          |
| orig_filename             | Исходное имя файла                              |
| orig_ext                  | Исходное расширение файла                       |
| width                     | Ширина в пикселях (для изображений)             |
| height                    | Высота в пикселях (для изображений)             |
| resolution                | Разрешение в Mpx (для изображений)              |
| duration                  | Длительность в секундах (для видео)             |
| exif                      | Перечень exif данных (для фотографий)           |
|     Полуавтоматические    |                                                 |
| registered_on             | Дата добавления файла в систему                 |
| registered_by             | uuid того, кто добавил файл в систему           |
| tags                      | Перечень тегов для записи и всех наследников    |
| hidden_tags               | Тоже перечень тегов для записи и наследников, но они не будут отображаться на странице записи |
|          Ручные           |                                                 |
| comment                   | Произвольный текстовый комментарий              |
| users_can_see             | Перечень uuid пользователей, которые могут видеть эту запись |
| groups_can_see            | Перечень uuid групп, которые могут видеть эту запись |
| author                    | Имя автора (если это рисунок или фотография)    |
| author_url                | Личная страница или сайт автора                 |
| url                       | Адрес, по которому этот контент был найден в сети |
|          Вложенные        |                                                 |
| local                     | Параметры конкретно для этой записи. Структура полей такая же как у основной записи. Не наследуется |
| manual                    | Параметры персонально для файла. Структура полей такая же как у основной записи. Не наследуется |
| config                    | Аналогично config, но с большим приоритетом     |
| local_config              | Аналогично local_config, но с большим приоритетом |
| extras                    | Произвольная информация в формате JSON          |

Для всех записей в поле manual описание `config` не отличается
от `local_config`. Они оба не наследуются и не распространяются на другие
файлы.

Можно проигнорировать все поля и ничего не указывать. И никакие json файлы не
создавать. Система всё-равно обработает данные. Предполагается, что если файл
попал в каталог `origin`, значит пользователь хочет видеть его в системе.
Единственное условие - файл должен иметь совместимое расширение.

### Groups

Группы предназначены для упрощения распределения доступов по пользователям. В
конечном итоге для каждого пользователя будет сформирован перечень uuid
записей, которые он может смотреть. Но руками формировать эти записи было бы
запредельно муторно, поэтому и были придуманы группы.

Важно иметь в виду, что в конечном результате никаких групп не будет. Права
доступа раздаются персонально пользователям. Механизм групп работает только на
этапе анализа исходных данных.

Пример файла `~groups.json`:

```json
[
    {
        "uuid": "$=[group some group}",
        "name": "Public group",
        "users": [
            "${user user1}",
            "${user user2}",
            "${user user3}",
            "${user user4}"
        ]
    }
]
```

### Synonyms

Синонимы это перечни слов, которые предназначены для расширения наборов тегов.
Например, пользователь мог указать тег `mouse`. С помощью синонимов можно
автоматически добавить ко всем записям с таким тегом тег `mice` поскольку они
часто могут быть взаимозаменяемы.

Во время работы приложения синонимов также не существуют, они применяются
только на этапе анализа исходных данных.

Пример файла `~synonyms.json`:

```json
[
    {
        "uuid": "$=[synonym mouse]",
        "name": "Different names for mouse",
        "values": [
            "mouse",
            "mice"
        ]
    }
]
```

### Config

Перечень пар ключ-значение, позволяющий настраивать работу системы. Конфиг
позволяет отключать наследование тегов, делать файлы в каталоге зависимыми или
независимыми и т.д.

Пример файла `~config.json`:

```json
{
    "some": true,
    "other": false
}
```

Доступные для изменения параметры:

| Параметр                  | По умолчанию | Значение    |
| ------------------------- |--------------|-------------|
| add_location_to_tags      | true         | Добавить цепочку каталогов в теги (имя каждого родительского, а также текущего каталога станет тегом) |
| add_location_to_name      | true         | Сделать имя текущего каталога именем записи (если выключить, каталоги будут отображаться как файлы) |
| skip_fields               | []           | Не включать поля с такими именами в итоговый результат. Например можно убрать дату загрузки всех записей |
| add_exif                  | false        | Попытаться выделить и сохранить максимум информации о картинке (актуально для фотографий) |
| auto_registered_on        | false        | Определить дату добавления в систему по возрасту файла (уступает ручной настройке) |
| auto_registered_by        | true         | Считать, что запись добавил владелец каталога (уступает ручной настройке) |
| first_entry_as_cover      | true         | Для коллекции первый файл в каталоге использовать как обложку |
| unrelated_items           | false        | Считать, что файлы в каталоге не связаны между собой, не следить за их порядком |

### Local_config

Работает так же и содержит те же параметры, что и обычный `config`. Но
действует только в данном каталоге и не распространяется на наследников.

## Кеширование uuid

Одна из основных идей **omoide** - возможность полностью снести базу данных, а
потом восстановить её из исходников. Но при этом будут полностью потеряны все
uuid. В сущности, сами они не несут смысловой информации, но часто требуется
связывать записи между собой. Чтобы делать это предсказуемым образом, введён
механизм кеширования uuid.

Запись производится следующим образом:

```json
{
    "uuid": "$=[group some group]",
    "other": "${user public}"
}
```

Равно и квадратные скобки означают "сгенерировать uuid".

Фигурные скобки означают "подставить существующий uuid".

Первое слово в скобках обозначает сущность, для которой генерируется uuid.
Потом после пробела могут идти любые символы, они являются именем сущности.

Каждый uuid генерируется однажды и сохраняется в базе, повторной генерации не
происходит. При его применении он извлекается из кеша.
