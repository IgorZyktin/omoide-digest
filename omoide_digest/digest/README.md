# digest

Анализирует исходные файлы пользователя и сохраняет их в локальную базу. Каждый
каталог и каждый файл после этого станет отдельной записью в базе.

## Пример вызова

```shell
omoide-digest --origin /home/user/origin --root /home/user/omoide/root
```

## Логика работы

Предполагаемая структура пользовательских каталогов:

```
origin
  ├─── ~users.json
  └─── <user uuid>
           └─── folder
                  ├─── sub_folder
                  │        ├─── img1.jpg
                  │        ├─── img2.jpg
                  │        ├─── img3.jpg
                  │        ├─── ~meta.json
                  │        ├─── ~config.json
                  │        └─── ~local_config.json
                  └─── ~meta.json      
```

Каталог `origin` выступает корнем и хранит персональные каталоги всех
пользователей. Имена этих каталогов соответствуют UUID пользователей.

Внутри каждого из таких каталогов может располагаться произвольный набор файлов
и каталогов. Описание к ним делается через `json` или `yaml` файлы со
специальным именем, которое должно начинаться с `~`. В основном
зарезервированные имена относятся к создаваемым сущностям, использование для
них отдельного файла позволяет немного упростить структуру json файла и сделать
более явным представление о том, что где искать.

Особые имена файлов:

1. [~users.json](#Users) - перечень всех создаваемых пользователей.
1. [~groups.json](#Groups) - перечень всех создаваемых групп.
1. [~synonyms.json](#Synonyms) - перечень всех создаваемых синонимов.
1. [~config.json](#Config) - настройка этой записи и всех наследников.
1. [~local_config.json](#Local-config) - настройка только в рамках этого каталога.
1. [~meta.json](#Meta) - описание создаваемой корневой записи (одна на каталог).

## Основные идеи обработки

Каждый каталог и каждый файл станут записями. При этом система постарается
вытащить максимум информации из расположения файлов, например цепочка каталогов
может быть преобразована в цепочку тегов в соответствующей записи.

При этом получится дерево, по которому можно передавать параметры. Например,
если на верхнем уровне вы опишете теги, эти теги распространятся на все записи
в каталогах ниже. Важно понимать, что деревьев в итоговом варианте не будет,
родительские записи от дочерних отличаться будут только набором тегов.
Наследование параметров распространяется при анализе исходников и заполнении
базы, но во время работы приложения уже не используется.

### Users

Внутри **omoide** пользователи представлены крайне просто - у них только uuid и
псевдоним. Полноценные пользователи будут существовать в приложении, здесь же
это просто ключи для контроля доступа. Все пользовательские настройки, имя,
адрес и тому подобное должны храниться и обрабатываться в приложении.

uuid пользователя здесь и в приложении тоже разные, но для работы они
должны быть сопоставлены один к одному.

Пример файла `~users.json`:

```json
[
    {
        "uuid": "$=[user public]",
        "byname": "Public user"
    },
    {
        "uuid": "$=[user private]",
        "byname": "Private user"
    }
]
```

Параметр `byname` ни на что не влияет и используется администратором для
различения пользователей.

Про uuid можно прочитать в разделе [Кеширование uuid](#Кеширование-uuid).

Не наследуются и не распространяются по дочерним каталогам, просто создают 
сущность в базе.

### Groups

Группы предназначены для упрощения распределения доступов по пользователям. В
конечном итоге для каждого пользователя будет сформирован перечень uuid
записей, которые он может смотреть. Но руками формировать эти записи было бы
слишком сложно, поэтому и были придуманы группы.

Важно иметь в виду, что в конечном результате никаких групп не будет. Права
доступа раздаются персонально пользователям. Механизм групп работает только на
этапе анализа исходных данных.

Пример файла `~groups.json`:

```json
[
    {
        "uuid": "$=[group some group]",
        "name": "Public group",
        "users": [
            "${user user1}",
            "${user user2}",
            "${user user3}",
            "${user user4}"
        ]
    }
]
```

Не наследуются и не распространяются по дочерним каталогам, просто создают 
сущность в базе.

### Synonyms

Синонимы это перечни слов, которые предназначены для расширения наборов тегов.
Например, пользователь мог указать тег `mouse`. С помощью синонимов можно
автоматически добавить ко всем записям с таким тегом тег `mice` поскольку они
часто могут быть взаимозаменяемы.

Во время работы приложения синонимов также не существуют, они применяются
только на этапе анализа исходных данных.

Пример файла `~synonyms.json`:

```json
[
    {
        "uuid": "$=[synonym mouse]",
        "name": "Different names for mouse",
        "values": [
            "mouse",
            "mice"
        ]
    }
]
```

Не наследуются и не распространяются по дочерним каталогам, просто создают 
сущность в базе.

### Config

Перечень пар ключ-значение, позволяющий настраивать работу системы. Конфиг
позволяет отключать наследование тегов, делать файлы в каталоге зависимыми или
независимыми и т.д.

Пример файла `~config.json`:

```json
{
    "some": true,
    "other": false
}
```

Доступные для изменения параметры:

| Параметр                  | По умолчанию | Значение    |
| ------------------------- |--------------|-------------|
| add_location_to_tags      | true         | Добавить цепочку каталогов в теги (имя каждого родительского, а также текущего каталога станет тегом) |
| folders_as_collections    | true         | Сделать все каталоги коллекциями. Если выключить, каталоги будут отображаться как файлы. Может быть актуально если запись состоит из одного файла |
| skip_fields               | []           | Не включать поля с такими именами в итоговый результат. Например можно убрать дату загрузки всех записей |
| add_exif                  | false        | Попытаться выделить и сохранить максимум информации о картинке (актуально для фотографий) |
| year_tag_from_exif        | false        | Попытаться выделить год из exif и сохранить как тег |
| month_tag_from_exif_ru    | false        | Попытаться выделить месяц-год из exif и сохранить как тег, например `январь 2021` |
| month_tag_from_exif_en    | false        | Попытаться выделить месяц-год из exif и сохранить как тег, например `january 2021` |
| day_tag_from_exif_ru      | false        | Попытаться выделить день-месяц-год из exif и сохранить как тег, например `14 января 2021` |
| day_tag_from_exif_en      | false        | Попытаться выделить день-месяц-год из exif и сохранить как тег, например `14 of january 2021` |
| auto_registered_on        | false        | Определить дату добавления в систему по возрасту файла |
| auto_registered_by        | true         | Считать, что запись добавил владелец каталога |
| first_entry_as_cover      | true         | Для коллекции первый файл в каталоге использовать как обложку |
| unrelated_items           | false        | Считать, что файлы в каталоге не связаны между собой, не следить за их порядком |

### Local config

Работает так же и содержит те же параметры, что и обычный 
[~config.json](#Config). Но действует только в данном каталоге и не 
распространяется на наследников.

### Meta

Описание генерации корневой записи, краеугольный камень всей системы. От его 
подробности напрямую зависит качество поиска.

В общем случае один каталог это одна запись. Например, одна книга. Каждая из
страниц книги тоже станет записью, но их описание формируется в неявном виде.
Другими словами, говоря о записях следует в первую очередь представлять себе 
каталоги, а не файлы.

Пример `~meta.json` с полным синтаксисом для записи:

```json
{
    "name": "Some name",
    "exif": {},
    "extras": {},
    "tags": [
        "browney"
    ],
    "hidden_tags": [
        "some tag"
    ],
    "users_can_see": [
        "${user user4}"
    ],
    "groups_can_see": [
        "${group public}"
    ],
    "registered_on": "2021-08-14",
    "registered_by": "${user public}",
    "comment": "",
    "type": "image",
    "author": "John Smith",
    "author_url": "https://somsite.com/john-smith",
    "source": "https://somsite.com/images/some.jpg",
    "orig_filename": "somefile",
    "orig_ext": "jpg",
    "size": 8752,
    "width": 640,
    "height": 480,
    "local": {},
    "config": {},
    "local_config": {},
    "per_file": {
        "animal-1239134.jpg": {
            "tags": [
                "apple"
            ],
            "config": {
                "add_exif": false
            }
        },
        "animal-1239402.jpg": {
            "tags": [
                "peanut"
            ]
        }
    }
}
```

Доступные для изменения параметры:

| Поле           | Получение  | Значение                                          |
| ---------------|------------|---------------------------------------------------|
| uuid           | Автоматич. | Идентификатор записи                              |
| parent_uuid    | Автоматич. | Идентификатор родительской записи (если есть)     |
| name           | Автоматич. | Имя записи, применяется для коллекций. Для файлов пустое |
| exif           | Автоматич. | Перечень exif данных (для фотографий)             |
| extras         | Ручное     | Произвольная информация в формате JSON            |
| tags           | Полуавт.   | Перечень тегов для записи и всех наследников      |
| hidden_tags    | Полуавт.   | Тоже перечень тегов для записи и наследников, но они не будут отображаться на странице записи |
| users_can_see  | Полуавт.   | Перечень uuid пользователей, которые могут видеть эту запись |
| groups_can_see | Полуавт.   | Перечень uuid групп, которые могут видеть эту запись |
|                |            |                                                   |
| registered_on  | Полуавт.   | Дата добавления файла в систему                   |
| registered_by  | Полуавт.   | uuid того, кто добавил файл в систему             |
| type           | Автоматич. | Тип записи: image, animated_image, video, etc.    |
| comment        | Ручное     | Произвольный текстовый комментарий                |
|                |            |                                                   |
| author         | Ручное     | Имя автора (если это рисунок или фотография)      |
| author_url     | Ручное     | Личная страница или сайт автора                   |
| source         | Ручное     | Адрес, по которому этот контент был найден в сети |
|                |            |                                                   |
| orig_filename  | Автоматич. | Исходное имя файла                                |
| orig_ext       | Автоматич. | Исходное расширение файла                         |
| size           | Автоматич. | Размер данных в байтах                            |
|                |            |                                                   |
| width          | Автоматич. | Ширина в пикселях (для изображений)               |
| height         | Автоматич. | Высота в пикселях (для изображений)               |
| resolution     | Автоматич. | Разрешение в Mpx (для изображений)                |
| duration       | Автоматич. | Длительность в секундах (для видео)               |
|                |            |                                                   |
| local          | Ручное     | Параметры конкретно для этой записи. Структура полей такая же как у основной записи. Имеет больший приоритет, чем основная запись. Не наследуется |
| per_file       | Ручное     | Параметры персонально для файла. Структура полей такая же как у основной записи. Имеет больший приоритет, чем основная запись. Не наследуется |
| config         | Ручное     | Аналогично файлу config, но с большим приоритетом |
| local_config   | Ручное     | Аналогично файлу local_config, но с большим приоритетом |
| override       | Ручное     | Принудительная установка любого параметра. Структура полей такая же как у основной записи. Имеет больший приоритет, чем основная запись. Наследуется. Может например изменить права доступа у всех потомков |

Для всех записей per_file поле `config` не отличается от `local_config`. 
Они оба не наследуются и не распространяются на другие файлы. 

`config` не отличается от `local_config` внутри записи действуют аналогично 
файлам с такими именами. Но рекомендуется пользоваться именно файлами, а 
локально указывать только очень специфичные настройки. Так будет проще найти, 
что стало причиной изменения в поведении.

Можно проигнорировать все поля и ничего не указывать. И никакие json файлы не
создавать. Система всё-равно обработает данные. Предполагается, что если файл
попал в каталог `origin`, значит пользователь хочет видеть его в системе.
Единственное условие - файл должен иметь совместимое расширение.

## Кеширование uuid

Одна из основных идей **omoide** - возможность полностью снести базу данных, а
потом восстановить её из исходников. Но при этом будут полностью потеряны все
uuid. В сущности, сами они не несут смысловой информации, но часто требуется
связывать записи между собой. Чтобы делать это предсказуемым образом, введён
механизм кеширования uuid.

Запись производится следующим образом:

```json
{
    "uuid": "$=[group some group]",
    "other": "${user public}"
}
```

Доллар + равно + квадратные скобки означают "сгенерировать uuid".

Доллар + фигурные скобки означают "подставить существующий uuid".

Первое слово в скобках обозначает сущность, для которой генерируется uuid.
Потом после пробела могут идти любые символы, они являются именем сущности.

Каждый uuid генерируется однажды и сохраняется в базе, повторной генерации не
происходит. При его применении он извлекается из кеша.

Кроме uuid, такая система подмены переменных может применяться и для других 
сущностей.
